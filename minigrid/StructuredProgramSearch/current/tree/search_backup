# NOTE: each node is associated with a sketch
import enum
import queue
import time
import copy
import random
from queue import PriorityQueue

import numpy as np

from dsl import *
from karel.robot import KarelRobot

import pdb

def get_structural_cost(program):
    cost = 0
    program_str = str(program)
    for s in ACTION_DICT:
        cost += program_str.count(s)

    return cost


# NOTE: each node is associated with a sketch
class Node:
    def __init__(self, 
            sketch, 
            task, 
            seed=123,
            more_seeds=[],
            max_search_iter = 50,
            max_structural_cost = 30,
            shuffle_actions=False):
        
        self.sketch = sketch
        self.task = task
        self.seed = seed
        self.more_seeds = more_seeds
        self.max_search_iter = max_search_iter
        self.max_structural_cost = max_structural_cost
        self.shuffle_actions = shuffle_actions

        self.robot = KarelRobot(self.task, seed=self.seed)

        self.q = PriorityQueue()
        self.q.put((
            0,  # reward
            time.time(), # timestamp
            copy.deepcopy(self.sketch),
            {
                'robot': copy.deepcopy(self.robot),
            }
        ))
        # NOTE: tmp code, store potential case 3 programs? not so sure
        self.case_3_list = []
 
        self.candidates = {  # store success (and unsuccess) programs
            'success': [],
            'failed': [],
            'no_fuel': [],
            'complete': []
        }

        # TODO: # number of top-k programs we select from a node
        self.k = 1

    def eval_program(self, seed, candidate, check_multiple, look_ahead=True):
        success = False
        single_seed = len(self.more_seeds) == 0
        check_multiple = False if single_seed else check_multiple
     
        eval_robot = KarelRobot(task=self.task, seed=seed)
        candidate.execute(eval_robot)
        r = eval_robot.check_reward()


        # force_eval_robot = KarelRobot(task=self.task, seed=seed)
        # force_eval_robot.force_execution = True
        # candidate.execute(force_eval_robot)
        # candidate.reset()  # NOTE: we should deepcopy candidate here, otherwise candidate.complete() may be wrong
        # force_eval_robot.force_execution = False
        # f_r = force_eval_robot.check_reward()
        f_r = 0

        if r == 1 or f_r == 1:
            print('[we found it, w]', candidate)
            # pdb.set_trace()
            if check_multiple:
                passed = True
                for e in self.more_seeds:
                    force_eval_robot = KarelRobot(task=self.task, seed=e)
                    force_eval_robot.force_execution = True
                    candidate.execute(force_eval_robot)
                    candidate.reset()
                    force_eval_robot.force_execution = False
                    passed = passed and force_eval_robot.check_reward() == 1
                    if not passed:
                        print('[failed on other tests]')
                        self.eval_program(e, candidate, check_multiple=False)
                        break
                # passed = True
                # for e in self.more_seeds:
                #     passed = passed and self.eval_program(e, candidate, check_multiple=False)
                #     if not passed:
                #         break
                if passed:
                    self.candidates['success'].append((1, candidate))
            else:
                # avoid insert duplicate programs
                success = True
                if single_seed:
                    self.candidates['success'].append((1, candidate))
        elif r == -1:
            print('[failed, w]', candidate)
            self.candidates['failed'].append((-1, candidate))
        elif eval_robot.no_fuel():
            print('[no fuel, w]')
            self.candidates['no_fuel'].append((r, candidate))
        elif candidate.complete():
            print('[complete, w]')
            self.candidates['complete'].append((r, candidate))
        else:
            
            # reactivate robot & reset program
            eval_robot.active = True
            candidate.reset()

            # find break point
            bp_stmts, bp_idx = candidate.find_break_point()
            bp = bp_stmts[bp_idx]

            # determine cond at break_point IF
            # pdb.set_trace()
            diff_conds = get_diff_conds(bp.abs_state, bp.obs_abs_state)

            # TODO: consider multiple locations to insert
            # print(candidate, bp_stmts[bp_idx])
            # for k in range(len(bp_stmts), 0, -1):
            #     print(k)
            # exit()

            # TODO: number of IFs before bp
            # pdb.set_trace()
            loc = bp_idx
            while loc-1 >= 0 and isinstance(bp_stmts[loc-1], IF):
                loc -= 1
            # num_ifs = bp_idx - loc - 1
            if_start_id = loc
            
            # if len(diff_conds) > 0:
            #     print(candidate)
            #     # pdb.set_trace()

            # for k in range(num_ifs + 1):
            for k in range(if_start_id, bp_idx+1):
                print('[k]', k)
                # insert IF(cond) {C} at break point
                for j in range(len(diff_conds)):
                    bp_stmts.insert(k, IF(cond=diff_conds[j]))                

                    # pdb.set_trace()

                    cost = get_structural_cost(candidate)
                    q_tuple = (
                        -r + cost * 0.01,
                        time.time(),
                        copy.deepcopy(candidate),
                        {
                            'robot': eval_robot,
                        }
                    )
                    if not cost > self.max_structural_cost:
                        self.q.put(q_tuple)
                    bp_stmts.pop(k)
                    
            # NOTE: optimized version of insertion of IF
            # insert IF(cond) {C} at break point
            # for j in range(len(diff_conds)):
            #     bp_stmts.insert(bp_idx, IF(cond=diff_conds[j]))

            #     pdb.set_trace()

            #     cost = get_structural_cost(candidate)
            #     q_tuple = (
            #         -r + cost * 0.01,
            #         time.time(),
            #         copy.deepcopy(candidate),
            #         {
            #             'robot': eval_robot,
            #         }
            #     )
            #     if not cost > self.max_structural_cost:
            #         self.q.put(q_tuple)
            #     bp_stmts.pop(bp_idx)
            
            # handle potential case 3 situations, look ahead
            if look_ahead:

                start_end_idx = []  # may trigger multiple case 3
                new_IF_code = []

                # NOTE: number of IF? number of ACTION?
                len_bp_stmts = len(bp_stmts)  # NOTE: C has beeen removed
                len_bp_stmts_effective = 0
                for k in range(bp_idx, len_bp_stmts):
                    if isinstance(bp_stmts[k], ACTION):
                        len_bp_stmts_effective += 1
                
                if len_bp_stmts_effective >= 2:
                    
                    start_idx = bp_idx  # starting point of case 3 IF branch, will not change
                    end_idx = bp_idx + 1  # end point of case 3 IF branch (exclude)

                    for end_idx in range(start_idx + 1, len_bp_stmts):
                        
                        tmp_end_action = bp_stmts[end_idx]
                        if not isinstance(tmp_end_action, ACTION):
                            continue

                        _eval_robot = copy.deepcopy(eval_robot)
                        _eval_robot.execute_single_action(tmp_end_action.action)
                        _eval_robot_current_state = get_abs_state(_eval_robot)

                        if satisfy_abs_state(tmp_end_action.post_abs_state, _eval_robot_current_state):
    
                            _bp_stmts = copy.deepcopy(bp_stmts)
                            for j in range(len(diff_conds)):
                                neg_cond = get_neg_cond(diff_conds[j])
                                IF_code = IF(cond=neg_cond)
                                IF_code.stmts.pop()  # remove C
                                IF_code.stmts += _bp_stmts[start_idx: end_idx]
                                
                                start_end_idx.append((start_idx, end_idx))
                                new_IF_code.append(IF_code)

                # print('[debug][any new code?]')
                # for code in new_IF_code:
                #     print('[code][new_code]', code)

                assert len(start_end_idx) == len(new_IF_code)
                for k in range(len(new_IF_code)):

                    _candidate = copy.deepcopy(candidate)
                    _bp_stmts, _bp_idx = _candidate.find_break_point()
                    
                    (_start, _end) = start_end_idx[k]
                    _bp_stmts[_start: _end] = []
                    _bp_stmts.insert(_end-1, new_IF_code[k])
                    _candidate.reset()

                    self.eval_program(self.seed, _candidate, check_multiple=True, look_ahead=False)
                    self.case_3_list.append(copy.deepcopy(_candidate))  # NOTE: not so sure

        return success

    def search(self):
        
        for iter in range(self.max_search_iter):

            print('[ITER]', iter)

            # pdb.set_trace()

            # 1) get program, find c and its cond
            try:
                r, ts, p, game = self.q.get_nowait()
            except queue.Empty:
                break
            else:
                robot = game['robot']
                c_cond, cond_type = p.find_c_cond()
                # NOTE: for sequential C program
                # WHILE(xxx) {action_1} ; C ; END
                # c_cond is None, cond_type is also None
                # TODO: handle this situation
                if c_cond is None:
                    c_stmts, c_index = p.find_seq_c()
                    assert not c_stmts is None
                if get_structural_cost(p) >= self.max_structural_cost:
                    continue

            # 2) expand actions
            p_list = p.expand_actions()
            index = list(range(len(WRAPPED_ACTION_LIST)))
            if self.shuffle_actions:
                random.shuffle(index)

            for p_i in index:
                print(p_list[p_i])
            
            # 3) ranking and put
            for i in index:

                print('[' + str(i) + ']')
                
                _robot = copy.deepcopy(robot)  # one-time-use for evaluation
                if _robot.while_start_robot_pos is None:
                    _robot.while_start_robot_pos = _robot.checker.get_hero_pos(_robot.get_state())

                tmp_action = copy.deepcopy(WRAPPED_ACTION_LIST[i])

                # get abs_state
                tmp_abs_state = get_abs_state(_robot)
                tmp_r = _robot.execute_single_action(tmp_action.action)
                tmp_post_abs_state = get_abs_state(_robot)

                if not _robot.while_start_robot_pos is None:
                    if _robot.checker.get_hero_pos(_robot.get_state()) != _robot.while_start_robot_pos:
                        _robot.while_moved = True

                # working on candidate program
                candidate = p_list[i]

                if tmp_r == 1:
                    
                    # find C
                    c_stmts, c_idx = candidate.find_actions()
                    tmp_action.abs_state = tmp_abs_state
                    tmp_action.post_abs_state = tmp_post_abs_state
                    c_stmts[c_idx-1] = tmp_action
                    c_stmts.pop(c_idx)  # remove C

                    bp_stmts, bp_idx = candidate.find_break_point()
                    if not bp_stmts is None:
                        bp = bp_stmts[bp_idx]

                        # NOTE: merget the final action
                        # TODO: try to merge multiple actions, not just the final one
                        if cond_type == 'i' and tmp_action.action.action == bp.action.action:
                            if len(c_stmts) == 1:
                                bp_stmts.pop(bp_idx-1)
                                bp.abs_state = merge_abs_state(bp.abs_state, tmp_abs_state)
                            else:
                                c_stmts.pop(c_idx-1)  # remove duplicate action            
                        
                        self.eval_program(self.seed, copy.deepcopy(candidate), check_multiple=True)
                        continue

                elif tmp_r == -1:
                    self.candidates['failed'].append(candidate)
                    continue

                simple_expand = None

                if cond_type == 'w':

                    if _robot.execute_single_cond(c_cond) and _robot.while_moved:
                        _robot.while_start_robot_pos = None
                        _robot.while_moved = False  # NOTE: we should reset (maybe unnecessary?)
                        c_stmts, c_idx = candidate.find_actions()
                        tmp_action.abs_state = tmp_abs_state
                        tmp_action.post_abs_state = tmp_post_abs_state
                        c_stmts[c_idx-1] = tmp_action
                        c_stmts.pop(c_idx)  # remove C
                        tmp_c_cond, tmp_cond_type = candidate.find_c_cond()
                        if tmp_c_cond is None:
                            self.eval_program(self.seed, copy.deepcopy(candidate), check_multiple=True)
                        else:
                            # should restart newly completed WHILE
                            print('[should restart]')
                            update_robot = KarelRobot(task=self.task, seed=self.seed)
                            update_robot.force_execution = True
                            candidate.execute(update_robot)
                            update_robot.force_execution = False
                            candidate.reset()
                            _robot = update_robot
                            simple_expand = True

                    else:
                        print('[should expand]')
                        simple_expand = True

                elif cond_type == 'i':

                    # find break point
                    bp_stmts, bp_idx = candidate.find_break_point()
                    bp = bp_stmts[bp_idx]

                    # find C
                    c_stmts, c_idx = candidate.find_actions()
                    
                    # handle case one here
                    if len(c_stmts) == 2 and tmp_action.action.action == bp.action.action:
                        # print(candidate)
                        # pdb.set_trace()

                        # find index to pop
                        drop_id = bp_idx-1
                        while drop_id > 0 and isinstance(bp_stmts[drop_id], IF):
                            if len(bp_stmts[drop_id].stmts) == 2 and bp_stmts[drop_id].stmts[0] == c_stmts[0] and bp_stmts[drop_id].stmts[1] == c_stmts[1]:
                                break
                            drop_id -= 1

                        # bp_stmts.pop(bp_idx-1)
                        bp_stmts.pop(drop_id)
                        current_abs_state = get_abs_state(_robot)
                        bp.abs_state = merge_abs_state(bp.abs_state, tmp_abs_state)
                        bp.obs_abs_state = tmp_abs_state
                        bp.break_point = False

                        # print(candidate)
                        # pdb.set_trace()
                        self.eval_program(self.seed, copy.deepcopy(candidate), check_multiple=True)

                    else:
                        tmp_action.abs_state = tmp_abs_state
                        tmp_action.post_abs_state = tmp_post_abs_state
                        c_stmts[c_idx-1] = tmp_action
                        current_abs_state = get_abs_state(_robot)

                        # try to connect to the break point
                        if tmp_action.action.action == bp.action.action and satisfy_abs_state(current_abs_state, bp.post_abs_state):
                            
                            bp.abs_state = merge_abs_state(bp.abs_state, tmp_abs_state)
                            bp.break_point = False
                            c_stmts.pop(c_idx)  # remove C
                            c_stmts.pop(c_idx-1)  # remove duplicate action
                            
                            tmp_c_cond, tmp_cond_type = candidate.find_c_cond()
                            if tmp_c_cond is None:
                                self.eval_program(self.seed, copy.deepcopy(candidate), check_multiple=True)
                            else:
                                # should restart newly completed WHILE
                                update_robot = KarelRobot(task=self.task, seed=self.seed)
                                update_robot.force_execution = True
                                candidate.execute(update_robot)
                                update_robot.force_execution = False
                                candidate.reset()
                                _robot = update_robot
                                simple_expand = True

                        else:
                            simple_expand = True

                # TODO: handle sequential C situation
                elif cond_type is None:
                    simple_expand = True

                if simple_expand:
                    c_stmts, c_idx = candidate.find_actions()
                    c_stmts[c_idx-1].abs_state = tmp_abs_state
                    c_stmts[c_idx-1].post_abs_state = tmp_post_abs_state
                    
                    cost = get_structural_cost(candidate)
                    q_tuple = (
                        -tmp_r + cost * 0.01 ,  # primary: retreive item with the highest reward
                        time.time(),  # the final evaluation metric
                        copy.deepcopy(candidate),
                        {
                            'robot': _robot,
                        }
                    )
                    
                    if not cost > self.max_structural_cost:
                        self.q.put(q_tuple)

        # TODO: tmp code for printing
        #print(self.candidates)
        #print(self.q.qsize())
        print('[success programs]')
        for reward, program in self.candidates['success']:
            print(program)

        print('[case 3]')
        for _p in self.case_3_list:
            print(_p)


# TODO: 1) set structural cost limit [done]
#       2-1) case 1 [done] 
#       2-2) case 2 [done]
#       2-3) case 3 (optional)
#       2) N = 3 test cases for success program [done]
#       3) multiple C in a sketch [done]
#       4) check chain of rules [done]
#       5) candidate.execute(eval_robot), stop when reward is 1 or -1 [done]
#       6) shuffle WRAPPED_ACTION_LIST / COND_LIST [done]
#       7) topOff [done*]
#       8) stairClimber [done*]
#       9) fourCorner [done*]
#      10) randomMaze ----> generator is not fixed?


if __name__ == "__main__":

    random.seed(123)
    np.random.seed(123)

    # NOTE: for simplicity, not a tree right now
    program_db = []

    p = Program()
    program_db.append(p)

    _p = copy.deepcopy(program_db[0])
    program_db += _p.expand()

    _p = copy.deepcopy(program_db[1])
    program_db += _p.expand()

    _p = copy.deepcopy(program_db[2])
    program_db += _p.expand()

    _p = copy.deepcopy(program_db[3])
    program_db += _p.expand()

    
    # task    : topOff
    # program : WHILE(front_is_clear) { C } ; S ; END
    # example_program = program_db[-2]
    # node = Node(sketch=example_program, task='topOff', seed=123, more_seeds=[999, 321], max_search_iter=100, max_structural_cost=20, shuffle_actions=True)
    # node.search()

    # task    : stairClimber
    # program : WHILE(not (front_is_clear)) { C } ; S ; END
    # example_program = program_db[7].expand()[0]
    # node = Node(sketch=example_program, task='stairClimber', seed=321, more_seeds=[1, 123], max_search_iter=100, max_structural_cost=20, shuffle_actions=True)
    # node.search()
    
    # task    : fourCorner
    # program : WHILE(not (markers_present)) { WHILE(front_is_clear) { C } ; C } ; S ; END
    # example_program = copy.deepcopy(program_db[-3]).expand()[-1].expand()[0].expand()[0].expand()[0]
    # node = Node(sketch=example_program, task='fourCorners', seed=123, more_seeds=[], max_search_iter=100, max_structural_cost=20, shuffle_actions=True)
    # node.search()

    # task    : randomMaze
    # program : WHILE(not (markers_present)) { WHILE(front_is_clear) { C } ; C } ; S ; END
    example_program = copy.deepcopy(program_db[-3]).expand()[-1].expand()[0].expand()[0].expand()[0]
    #more_seeds = [666, 546, 321, 11]
    #more_seeds = [666]
    more_seeds = []
    node = Node(sketch=example_program, task='randomMaze', seed=666, more_seeds=more_seeds, max_search_iter=300, max_structural_cost=40, shuffle_actions=True)
    node.search()

    # NOTE: seed=123, iter=100 can learn
    # NOTE: seed=321, iter=1000 can learn