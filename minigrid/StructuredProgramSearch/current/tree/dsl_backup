import copy
import time

from numpy import isin

from karel.dsl import k_cond, k_cond_without_not, k_action
from karel.robot import KarelRobot

import pdb

ACTION_DICT = {
    'move'        : k_action('move'),
    'turn_right'  : k_action('turn_right'),
    'turn_left'   : k_action('turn_left'),
    'pick_marker' : k_action('pick_marker'),
    'put_marker'  : k_action('put_marker')
}
ACTION_NAME = [e for e in ACTION_DICT]
ACTION_LIST = [ACTION_DICT[e] for e in ACTION_DICT]


COND_DICT = {
    'front_is_clear'    : k_cond(negation=False, cond=k_cond_without_not('front_is_clear')),
    'left_is_clear'     : k_cond(negation=False, cond=k_cond_without_not('left_is_clear')),
    'right_is_clear'    : k_cond(negation=False, cond=k_cond_without_not('right_is_clear')),
    'markers_present': k_cond(negation=False, cond=k_cond_without_not('markers_present')),
    'not(front_is_clear)'    : k_cond(negation=True, cond=k_cond_without_not('front_is_clear')),
    'not(left_is_clear)'     : k_cond(negation=True, cond=k_cond_without_not('left_is_clear')),
    'not(right_is_clear)'    : k_cond(negation=True, cond=k_cond_without_not('right_is_clear')),
    'not(markers_present)': k_cond(negation=True, cond=k_cond_without_not('markers_present')),
}
COND_NAME = [e for e in COND_DICT]
COND_LIST = [COND_DICT[e] for e in COND_DICT]


class ABS_STATE:
    def __init__(self):
        self.state = {
            'front_is_clear'    : None,
            'left_is_clear'     : None,
            'right_is_clear'    : None,
            'markers_present'   : None,
        }

    def update(self, cond, description: str):
        # description: T / F / DNC
        self.state[str(cond)] = description

def get_abs_state(robot):
    abs_state = ABS_STATE()
    for cond in COND_LIST[:4]:
        if robot.execute_single_cond(cond):
            abs_state.update(cond, 'T')
        else:
            abs_state.update(cond, 'F')
    
    return abs_state


def satisfy_abs_state(current, required):
    satisfied = True
    for e in required.state:
        if required.state[e] == 'DNC':  # does not care
            pass
        elif current.state[e] != required.state[e]:  
            satisfied = False
            break

    return satisfied


def get_diff_abs_state(code_abs_state, obs_abs_state):
    diff_abs_state = []
    for e in code_abs_state.state:
        if obs_abs_state.state[e] != code_abs_state.state[e]:
            if code_abs_state.state[e] == 'DNC':
                pass
            else:
                diff_abs_state.append(e)

    return diff_abs_state


def get_diff_conds(code_abs_state, obs_abs_state):
    diff_conds = []  # can be multiple conds
    for e in code_abs_state.state:
        if obs_abs_state.state[e] != code_abs_state.state[e]:
            if code_abs_state.state[e] == 'DNC':
                pass
            elif code_abs_state.state[e] == 'T':
                diff_conds.append(COND_DICT['not(' + e + ')'])
            elif code_abs_state.state[e] == 'F':
                diff_conds.append(COND_DICT[e])

    return diff_conds


def get_neg_cond(cond):
    
    cond_name = str(cond)
    print(cond_name)
    if 'not' in cond_name:
        neg_cond_name = cond_name.replace('not', '').replace('(', '').replace(')', '')
        neg_cond_name = neg_cond_name.replace(' ', '')
        return COND_DICT[neg_cond_name]
    else:
        cond_name = cond_name.replace(' ', '')
        for key in COND_DICT:
            if 'not' in key and cond_name in key:
                return COND_DICT[key]


def merge_abs_state(abs_state, new_abs_state):
    s = copy.deepcopy(abs_state)
    for e in s.state:
        if s.state[e] != new_abs_state.state[e]:
            s.state[e] = 'DNC'

    return s


class ACTION:
    def __init__(self, action):
        self.abs_state = None
        self.action = action
        
        # NOTE: used for adding new IF branch
        self.break_point = False
        self.obs_abs_state = None
        self.post_abs_state = None

    def execute(self, robot):
        if robot.active:
            if robot.force_execution:  # without considering abs_state
                r = robot.execute_single_action(self.action)
                if r == 1 or r == -1:
                    robot.active = False
            else:
                if satisfy_abs_state(get_abs_state(robot), self.abs_state):
                    r = robot.execute_single_action(self.action)
                    # modify post abstrate state here (TODO: whether good to put here?)
                    assert self.post_abs_state is not None
                    new_robot_state = get_abs_state(robot)
                    if not satisfy_abs_state(new_robot_state, self.post_abs_state):
                        # pdb.set_trace()
                        self.post_abs_state = merge_abs_state(self.post_abs_state, new_robot_state)
                    # NOTE: terminate when success (or failed)
                    if r == 1 or r == -1:
                        robot.active = False
                else:
                    self.break_point = True
                    self.bp_time = time.time()
                    self.obs_abs_state = get_abs_state(robot)
                    robot.active = False

    def __str__(self):
        return str(self.action)

    def pretty_print(self):
        pass


# store action used to end if branch
class HIDE_ACTION:
    def __init__(self, action):
        self.abs_state = None
        self.action = action
        
        self.break_point = False
        self.obs_abs_state = None
        self.post_abs_state = None

    def execute(self, robot):
        pass

    def __str__(self):
        return ''

    def pretty_print(self):
        pass


WRAPPED_ACTION_LIST = [ACTION(e) for e in ACTION_LIST]


# search DSL
# S -> while B do S; S | C
# B -> conds

# NOTE: treate C as terminals
#       C does not contribute to the sketch


class C:
    def __init__(self):
        self.stmts = []

    #def execute(self, robot):
    #    raise NotImplementedError('Invalid code')
    def execute(self, robot):
        robot.active = False

    def __str__(self):
        return ' C '

class B:
    def __init__(self):
        self.cond = None

    def execute(self, robot):
        raise NotImplementedError('Invalid code')

    def __str__(self):
        return ' B ' if self.cond is None else str(self.cond)


class S:
    def __init__(self):
        self.stmts = []
    
    def execute(self, robot):
        if robot.active and not robot.no_fuel():
            #print('[execute S, i.e., execute nothing]')
            pass

    def __str__(self):
        return ' S '


class SN:
    def __init__(self):
        self.stmts = []
    
    def execute(self, robot):
        # raise NotImplementedError('Invalid code')
        if robot.active and not robot.no_fuel():
            #print('[execute S, i.e., execute nothing]')
            pass

    def __str__(self):
        return 'SN'


# NOTE: used to check if program complete
class END:
    def __init__(self):
        self.visited = False

    def execute(self, robot):
        if robot.active:
            self.visited = True

    def __str__(self):
        return "; END"


class WHILE:
    def __init__(self):
        self.cond = [B()]
        self.stmts = [S()]

    def execute(self, robot):
        if robot.active and not robot.no_fuel():
            while robot.active and not robot.no_fuel() and robot.execute_single_cond(self.cond[0]):
                for s in self.stmts:
                    # NOTE: summarized as
                    s.execute(robot)
                # debug test
                robot.steps += 1

                # robot.draw()
                # pdb.set_trace()
                

    def __str__(self):
        string = ''
        string += ' WHILE(' + str(self.cond[0]) + ') {'
        for s in self.stmts:
            string += str(s)
        string += '} ;'

        return string


# NOTE: we will not synthesize IF directly
class IF:
    def __init__(self, cond=None):
        self.cond = [B() if cond is None else cond]
        self.stmts = [C()]

    def execute(self, robot):
        if robot.active and not robot.no_fuel():
            if robot.execute_single_cond(self.cond[0]):
                for s in self.stmts:
                    # NOTE: summarized as
                    s.execute(robot)

    def __str__(self):
        string = ''
        string += ' IF(' + str(self.cond[0]) + ') {'
        for s in self.stmts:
            string += str(s)
        string += '} '

        return string


class Program:
    def __init__(self):
        self.stmts = [S(), END()]
    
    def execute(self, robot):
        for s in self.stmts:
            s.execute(robot)

    def complete(self):
        assert isinstance(self.stmts[-1], END)
        return self.stmts[-1].visited

    def reset(self):
        self.stmts[-1].visited = False

    # NOTE: find S / B
    def find(self):
        stmts, idx = self._find(self.stmts)
        if stmts is None:
            return None, None, None
        else:
            code = stmts[idx]
            if isinstance(code, S):
                code_type = 'S'
            elif isinstance(code, B):
                code_type = 'B'
            elif isinstance(code, SN):
                code_type = 'SN'
            else:
                raise ValueError('Invalid code')
            return stmts, idx, code_type

    def _find(self, stmts):
        r_stmts, r_idx = None, None
        for idx, code in enumerate(stmts):
            if isinstance(code, (S, B, SN)):
                return stmts, idx
            elif isinstance(code, (WHILE, IF)):
                r_stmts, r_idx = self._find(code.cond)
                if r_stmts is None:
                    r_stmts, r_idx = self._find(code.stmts)
                if not r_stmts is None:
                    return r_stmts, r_idx
            elif isinstance(code, (ACTION, k_cond, C, END)):
                pass
            else:
                raise ValueError('Invalid code')
        
        return r_stmts, r_idx
    
    # NOTE: find cond that contains a C
    #       C presents in IF(cond) {C}, not just in WHILE
    def find_c_cond(self):
        self.c_cond, self.c_cond_type = None, None
        self.found_c = False
        self._find_c_cond(self.stmts)

        return self.c_cond, self.c_cond_type

    def _find_c_cond(self, stmts):
        for code in stmts:
            if isinstance(code, (WHILE, IF)):
                contains_c = False
                for s in code.stmts:
                    if isinstance(s, C):
                        contains_c = True
                if not self.found_c and contains_c:
                    self.c_cond, self.c_cond_type = code.cond[0], 'w' if isinstance(code, WHILE) else 'i'
                self._find_c_cond(code.stmts)
            elif isinstance(code, C):
                self.found_c = True

    def find_seq_c(self):
        c_stmts, c_index = None, None
        for idx, code in enumerate(self.stmts):
            if isinstance(code, C):
                c_index = idx
                c_stmts = self.stmts
        
        return c_stmts, c_index

    # NOTE: find C
    def find_actions(self):
        stmts, idx = self._find_actions(self.stmts)
        if stmts is None:
            return None, None
        else:
            code = stmts[idx]
            assert isinstance(code, C)
            return stmts, idx

    def _find_actions(self, stmts):
        r_stmts, r_idx = None, None
        for idx, code in enumerate(stmts):
            if isinstance(code, (S, B, ACTION, HIDE_ACTION, k_cond, END)):
                pass
            elif isinstance(code, (WHILE, IF)):
                r_stmts, r_idx = self._find_actions(code.stmts)
                if not r_stmts is None:
                    return r_stmts, r_idx
            elif isinstance(code, C):
                return stmts, idx
            else:
                pdb.set_trace()
                raise ValueError('Invalide code')
        
        return r_stmts, r_idx

    def find_break_point(self):
        stmts, idx = self._find_break_point(self.stmts)
        if stmts is None:
            return None, None
        else:
            code = stmts[idx]
            assert isinstance(code, ACTION) and code.break_point
            return stmts, idx

    def _find_break_point(self, stmts):
        r_stmts, r_idx = None, None
        for idx, code in enumerate(stmts):
            if isinstance(code, (S, B, C, HIDE_ACTION, k_cond, END)):
                pass
            elif isinstance(code, (WHILE, IF)):
                r_stmts, r_idx = self._find_break_point(code.stmts)
                if not r_stmts is None:
                    return r_stmts, r_idx
            elif isinstance(code, ACTION):
                if code.break_point:
                    return stmts, idx
            else:
                raise ValueError('Invalide code')
        
        return r_stmts, r_idx

    def find_new_break_point(self):
        
        bp_stmts, bp_idx, bp_time = None, None, 0

        stmts, idx = self.find_break_point()
        if not stmts is None:
            stmts[idx].break_point = False
        while not stmts is None:
            if stmts[idx].bp_time > bp_time:
                bp_time = stmts[idx].bp_time
                bp_stmts = stmts
                bp_idx = idx
            
            stmts, idx = self.find_break_point()  # left-most
            if not stmts is None:
                stmts[idx].break_point = False

        if not bp_stmts is None:
            bp_stmts[bp_idx].break_point = True

        return bp_stmts, bp_idx

    # NOTE: expand sketch
    def expand(self):
        p_list = []
        stmts, idx, code_type = self.find()
        # test parent sketch
        self_loop = False
        for code in self.stmts:
            if isinstance(code, WHILE):
                self_loop = True
                break
        # self_loop = True

        # expand B
        if code_type == 'B':
            for cond in COND_LIST:
                stmts[idx] = copy.deepcopy(cond)
                p_list.append(copy.deepcopy(self))

        # expand S
        elif code_type == 'S':
            if self_loop:
                stmts[idx] = C()
                p_list.append(copy.deepcopy(self))
            stmts[idx] = WHILE()
            stmts.insert(idx + 1, SN())
            p_list.append(copy.deepcopy(self))

        # expand SN
        elif code_type == 'SN':
            stmts[idx] = S()
            p_list.append(copy.deepcopy(self))
            stmts.pop(idx)
            p_list.append(copy.deepcopy(self))

        else:
            pass
        
        return p_list

    # NOTE: expand C to actions
    def expand_actions(self):
        p_list = []
        stmts, idx = self.find_actions()
        if not stmts is None:
            for action in WRAPPED_ACTION_LIST:
                stmts[idx] = copy.deepcopy(action)
                stmts.insert(idx + 1, C())
                p_list.append(copy.deepcopy(self))
                stmts.pop(idx + 1)
        else:
            pass
        
        return p_list

    def __str__(self):
        string = ''
        for s in self.stmts:
            string += str(s)
        
        return string


if __name__ == "__main__":

    # 1)
    print('[1]')
    p = Program()
    original = copy.deepcopy(p)  # NOTE: alway keep a original copy
    for _p in p.expand():
        print('[expand]', _p)
    print('[original]', original)
    print()

    #2)
    print('[2]')
    p = Program()
    p.stmts = [WHILE(), S()]
    original = copy.deepcopy(p)
    for _p in p.expand():
        print('[expand]', _p)
    print('[original]', original)
    print()
    
    # 3)
    print('[3]')
    p = Program()
    w1 = WHILE()
    w1.cond = [COND_LIST[0]]
    w2 = WHILE()
    w1.stmts = [w2, S()]
    p.stmts = [
        w1,
        S()
    ]
    original = copy.deepcopy(p)
    for _p in p.expand():
        print('[expand]', _p)
    print('[original]', original)
    print()

    # 4)
    print('[4]')
    p = Program()
    p.stmts = [C()]
    original = copy.deepcopy(p)
    for _p in p.expand_actions():
        print('[expand actions]', _p)
    print('[original]', original)
    print()

    # 5)
    print('[5]')
    p = Program()
    w1 = WHILE()
    w1.cond = [COND_LIST[0]]
    w2 = WHILE()
    w1.stmts = [w2, S()]
    p.stmts = [
        w1,
        S()
    ]
    p_list = p.expand_actions()
    assert len(p_list) == 0
    print('[nothing]')
    print()

    # 6)
    print('[6]')
    p = Program()
    w1 = WHILE()
    w1.cond = [COND_LIST[0]]
    w2 = WHILE()
    w2.cond = [COND_LIST[1]]
    w2.stmts = [C()]
    w1.stmts = [w2, S()]
    p.stmts = [
        w1,
        S()  # C() doesn't change results
    ]
    original = copy.deepcopy(p)
    for _p in p.expand_actions():
        print('[expand actions]', _p)
    print('[original]', original)
    print()


    # 7)
    print('[7]')
    p = Program()
    # while (front_is_clear) {
    #   pick_marker
    #   move
    #   C
    # }
    # S

    w = WHILE()
    w.cond = [COND_LIST[0]]  # front_is_clear
    w.stmts = [WRAPPED_ACTION_LIST[3], WRAPPED_ACTION_LIST[0], C()]  # pick_marker, move
    p.stmts = [
        w,
        S()
    ]
    original = copy.deepcopy(p)
    for _p in p.expand_actions():
        print('[expand actions]', _p)
    print('[original]', original)
    print()

    # 8)
    print('[8]')
    w = WHILE()
    w.cond = [COND_LIST[0]]  # front_is_clear
    i = IF()
    i.cond = [COND_LIST[7]]  # not(no_markers_present), i.e., markers_present
    i.stmts = [WRAPPED_ACTION_LIST[4], C()]  # put_marker
    w.stmts = [i, WRAPPED_ACTION_LIST[0]]  # if..., move
    p.stmts = [
        w,
        S()
    ]
    original = copy.deepcopy(p)
    for _p in p.expand_actions():
        print('[expand actions]', _p)
    print('[original]', original)
    print()

    # 9)
    print('[9]')
    w = WHILE()
    w.cond = [COND_LIST[0]]  # front_is_clear
    i = IF()
    i.cond = [COND_LIST[7]]  # not(no_markers_present), i.e., markers_present
    i.stmts = [WRAPPED_ACTION_LIST[4]]  # put_marker
    w.stmts = [i, WRAPPED_ACTION_LIST[0]]  # if..., move
    p.stmts = [
        w,
        S()
    ]
    original = copy.deepcopy(p)
    for _p in p.expand():
        print('[expand]', _p)
    print('[original]', original)
    print()

